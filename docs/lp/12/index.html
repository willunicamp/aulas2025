<!DOCTYPE html>
<html lang="pt-BR" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aula Mestra: Ponteiros em C</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700;900&family=Fira+Code:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Configura√ß√µes Gerais */
        body {
            font-family: 'Nunito', sans-serif;
            background-color: #f8fafc;
            color: #1e293b;
        }
        
        /* Slide / Se√ß√£o */
        .slide {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 3rem;
            border-bottom: 4px dashed #cbd5e1;
            position: relative;
        }
        
        /* T√≠tulos */
        h1 { font-size: 4rem; font-weight: 900; color: #0f172a; text-align: center; margin-bottom: 1rem; }
        h2 { font-size: 3rem; font-weight: 800; color: #1e293b; margin-bottom: 1.5rem; text-align: center; }
        p { font-size: 1.5rem; line-height: 1.6; margin-bottom: 1.5rem; max-width: 900px; text-align: center; }
        
        /* Destaques */
        .analogy { background-color: #fff7ed; border: 3px solid #fdba74; border-radius: 20px; padding: 2rem; margin-top: 1rem; max-width: 800px; }
        .analogy-icon { font-size: 4rem; display: block; text-align: center; margin-bottom: 1rem; }
        
        /* C√≥digo - Tema Monokai Light (Fundo Branco / Alto Contraste) */
        pre {
            background-color: #ffffff; /* Fundo Branco Puro */
            color: #333333;
            padding: 1.5rem;
            border-radius: 12px;
            border: 2px solid #e2e8f0; /* Borda para destacar do fundo */
            font-family: 'Fira Code', monospace;
            font-size: 1.3rem;
            line-height: 1.5;
            overflow-x: auto;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.05);
            max-width: 900px;
            width: 100%;
        }
        code { font-family: 'Fira Code', monospace; background-color: #f1f5f9; color: #0f172a; padding: 0.1em 0.3em; border-radius: 4px; font-size: 0.9em; border: 1px solid #e2e8f0; }
        
        /* Tokens de C√≥digo (Monokai Light Style) */
        .tok-kw { color: #d73a49; font-weight: bold; }      /* Keyword (Red/Pink) */
        .tok-type { color: #005cc5; font-weight: bold; }    /* Type (Blue) */
        .tok-num { color: #6f42c1; }                        /* Number (Purple) */
        .tok-str { color: #e36209; }                        /* String (Orange) */
        .tok-com { color: #6a737d; font-style: italic; }    /* Comment (Grey) */
        .tok-ptr { color: #d73a49; font-weight: bold; }     /* Pointer op (Red) */
        .tok-func { color: #6f42c1; font-weight: bold; }    /* Function Name */

        /* Navega√ß√£o */
        .nav-btn {
            position: fixed; bottom: 2rem; z-index: 50;
            background: #334155; color: white; width: 3.5rem; height: 3.5rem;
            border-radius: 50%; display: flex; align-items: center; justify-content: center;
            font-size: 1.5rem; box-shadow: 0 4px 6px rgba(0,0,0,0.2); cursor: pointer;
            transition: transform 0.1s;
        }
        .nav-btn:active { transform: scale(0.9); }
        .nav-prev { left: 2rem; }
        .nav-next { right: 2rem; }
        
        .counter {
            position: fixed; bottom: 2rem; left: 50%; transform: translateX(-50%);
            background-color: white; padding: 0.5rem 1.5rem; border-radius: 99px;
            font-size: 1rem; font-weight: 800; border: 2px solid #cbd5e1; color: #475569;
            z-index: 50; box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        /* Depurador */
        .debugger-container {
            display: flex; gap: 2rem; width: 100%; max-width: 1200px;
            background: white; padding: 2rem; border-radius: 16px;
            border: 2px solid #94a3b8; box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.05);
        }
        .code-panel { flex: 1; position: relative; }
        .memory-panel { flex: 1; border-left: 2px dashed #e2e8f0; padding-left: 2rem; }
        
        .debug-line { 
            padding: 2px 10px; border-radius: 4px; display: block; position: relative;
        }
        /* Linha Ativa */
        .debug-line.active { background-color: #fef08a; color: #000; font-weight: bold; box-shadow: -4px 0 0 #eab308; }
        /* Linha de Retorno (Call Site) */
        .debug-line.call-site { background-color: #e2e8f0; }
        .debug-line.call-site::after {
            content: "‚Ü© Retorno aqui"; position: absolute; right: 10px; font-size: 0.8em; color: #ef4444; font-weight: bold;
        }
        
        .mem-box {
            border: 2px solid #cbd5e1; border-radius: 8px; margin-bottom: 1rem;
            padding: 0.8rem; background: #f1f5f9; position: relative; transition: all 0.3s;
        }
        .mem-box.changed { background-color: #fef9c3; border-color: #eab308; transform: scale(1.02); }
        .mem-addr { font-size: 0.85rem; color: #64748b; font-family: monospace; position: absolute; top: -10px; left: 10px; background: white; padding: 0 5px; font-weight: bold; }
        .mem-name { font-weight: bold; color: #334155; font-size: 1.1rem; }
        .mem-val { font-family: 'Fira Code', monospace; font-size: 1.4rem; color: #0f172a; text-align: right; }
        
        .controls-help { text-align: center; color: #64748b; margin-top: 1rem; font-size: 1rem; font-weight: bold; background: #fff; display: inline-block; padding: 5px 15px; border-radius: 20px; border: 1px solid #ddd; }

        /* Impress√£o */
        @media print {
            .slide { height: 29.7cm; border-bottom: none; page-break-after: always; align-items: flex-start; padding: 2cm; }
            .nav-btn, .controls-help, .counter { display: none; }
            body { background-color: white; color: black; }
            .debugger-container { border: 1px solid #ccc; box-shadow: none; }
            pre { background-color: white; color: black; border: 1px solid #ccc; }
            h1, h2, p { text-align: left; }
            .analogy { border: 1px solid #ccc; }
        }
    </style>
</head>
<body>

    <!-- Navega√ß√£o -->
    <button class="nav-btn nav-prev" id="prevBtn">‚Üê</button>
    <div id="counter" class="counter">1 / 27</div>
    <button class="nav-btn nav-next" id="nextBtn">‚Üí</button>

    <!-- CONTE√öDO -->
    <main>

        <!-- 1. Capa -->
        <section class="slide" id="slide-1">
            <h1>Dominando Ponteiros</h1>
            <p class="text-2xl font-bold text-slate-600">O Guia Definitivo e Descomplicado</p>
            <div class="text-9xl mt-8">üß≠</div>
            <p class="mt-8 text-gray-500">Prof. William Paiva</p>
        </section>

        <!-- 2. Analogia Inicial -->
        <section class="slide">
            <h2>O Grande Arm√°rio da Mem√≥ria</h2>
            <p>Imagine que a mem√≥ria RAM do seu computador √© um <strong>arm√°rio gigante</strong> com milh√µes de gavetinhas.</p>
            <div class="text-6xl my-4">üóÑÔ∏è</div>
            <p>Cada gavetinha tem um n√∫mero √∫nico. Esse n√∫mero √© o <strong>Endere√ßo de Mem√≥ria</strong>.</p>
        </section>

        <!-- 3. Vari√°veis Comuns -->
        <section class="slide">
            <h2>Vari√°veis Comuns</h2>
            <p>Quando voc√™ cria uma vari√°vel normal (<code class="inline-code">int idade = 10;</code>), voc√™ est√° colando uma <strong>etiqueta</strong> com um nome ("idade") em uma dessas gavetas.</p>
            <div class="analogy">
                <span class="analogy-icon">üè∑Ô∏è</span>
                <p><strong>Vari√°vel:</strong> √â o apelido carinhoso que damos para uma gaveta.</p>
            </div>
        </section>

        <!-- 4. O Conceito de Ponteiro -->
        <section class="slide">
            <h2>O que √© um Ponteiro?</h2>
            <p>Um ponteiro √© uma vari√°vel especial. Ele n√£o guarda um n√∫mero comum, nem uma letra.</p>
            <p class="font-bold text-xl text-slate-800">Um ponteiro guarda o N√öMERO DA GAVETA de outra vari√°vel.</p>
            <div class="analogy">
                <span class="analogy-icon">üó∫Ô∏è</span>
                <p><strong>Ponteiro = Mapa do Tesouro.</strong><br>Ele n√£o √© o tesouro (o valor), ele diz <strong>ONDE</strong> o tesouro est√°.</p>
            </div>
        </section>

        <!-- 5. Operador & -->
        <section class="slide">
            <h2>Operador & (O "E" Comercial)</h2>
            <p>Como descobrimos o n√∫mero da gaveta de uma vari√°vel?</p>
            <p>Usamos o operador <code class="inline-code">&</code>. Ele significa: <strong>"O endere√ßo de..."</strong>.</p>
            <pre><span class="tok-type">int</span> numero = <span class="tok-num">50</span>;
<span class="tok-com">// &numero -> Vai me dar algo como 0x7fff...</span></pre>
        </section>

        <!-- 6. Operador * (Declara√ß√£o) -->
        <section class="slide">
            <h2>Criando o Mapa (Declara√ß√£o)</h2>
            <p>Para criar uma vari√°vel que vai guardar um endere√ßo (um ponteiro), usamos o asterisco <code class="inline-code">*</code> logo ap√≥s o tipo.</p>
            <pre><span class="tok-type">int</span> <span class="tok-ptr">*</span>p; 
<span class="tok-com">// "p" √© um ponteiro que vai apontar para um int.</span></pre>
            <p class="text-sm text-gray-500 mt-4">Nota: O tipo deve combinar! Ponteiro de int aponta para int.</p>
        </section>

        <!-- 7. Ligando os Pontos -->
        <section class="slide">
            <h2>Ligando o Ponteiro √† Vari√°vel</h2>
            <p>Agora vamos fazer o ponteiro <code class="inline-code">p</code> guardar o endere√ßo da vari√°vel <code class="inline-code">numero</code>.</p>
            <pre><span class="tok-type">int</span> numero = <span class="tok-num">50</span>;
<span class="tok-type">int</span> <span class="tok-ptr">*</span>p;

p = <span class="tok-ptr">&</span>numero; <span class="tok-com">// "p" agora sabe onde "numero" mora!</span></pre>
        </section>

        <!-- 8. Operador * (Acesso/Derrefer√™ncia) -->
        <section class="slide">
            <h2>O Controle Remoto (Derrefer√™ncia)</h2>
            <p>Agora que <code class="inline-code">p</code> sabe onde <code class="inline-code">numero</code> est√°, podemos usar o <code class="inline-code">*</code> <strong>antes</strong> do nome do ponteiro para acessar o valor l√° dentro.</p>
            <div class="analogy">
                <span class="analogy-icon">üì∫</span>
                <p><strong>*p = ...</strong><br>Significa: "V√° at√© o endere√ßo que est√° no mapa e mexa no que est√° l√° dentro".</p>
            </div>
            <pre><span class="tok-ptr">*</span>p = <span class="tok-num">100</span>; 
<span class="tok-com">// Isso altera "numero" para 100 remotamente!</span></pre>
        </section>

        <!-- 9. DEPURADOR 1 -->
        <section class="slide" data-debug="basic">
            <h2>Depurador: Ponteiros B√°sicos</h2>
            <p class="controls-help">Use a <strong>Seta Esquerda</strong> (‚Üê) para avan√ßar o passo a passo.</p>
            <div class="debugger-container mt-4">
                <div class="code-panel">
                    <pre id="code-basic">
<span class="debug-line" data-l="1"><span class="tok-type">int</span> main() {</span>
<span class="debug-line" data-l="2">    <span class="tok-type">int</span> a = <span class="tok-num">10</span>;</span>
<span class="debug-line" data-l="3">    <span class="tok-type">int</span> <span class="tok-ptr">*</span>ptr;</span>
<span class="debug-line" data-l="4">    ptr = <span class="tok-ptr">&</span>a;</span>
<span class="debug-line" data-l="5">    <span class="tok-ptr">*</span>ptr = <span class="tok-num">20</span>;</span>
<span class="debug-line" data-l="6">    <span class="tok-kw">return</span> <span class="tok-num">0</span>;</span>
<span class="debug-line" data-l="7">}</span>
                    </pre>
                </div>
                <div class="memory-panel" id="mem-basic">
                    <!-- Mem√≥ria ser√° gerada via JS -->
                </div>
            </div>
        </section>

        <!-- 10. Ponteiros e Fun√ß√µes - O Problema -->
        <section class="slide">
            <h2>O Problema das C√≥pias</h2>
            <p>Lembre-se: quando passamos uma vari√°vel para uma fun√ß√£o, a fun√ß√£o recebe uma <strong>XEROX (c√≥pia)</strong>.</p>
            <div class="text-6xl my-4">üìÑ ‚ûî üìÑ</div>
            <p>Se voc√™ rasurar a xerox, o documento original continua intacto. Por isso fun√ß√µes normais n√£o alteram vari√°veis da <code class="inline-code">main</code>.</p>
        </section>

        <!-- 11. A Solu√ß√£o: Passagem por Refer√™ncia -->
        <section class="slide">
            <h2>A Solu√ß√£o: Passagem por Refer√™ncia</h2>
            <p>Em vez de mandar a c√≥pia do documento, mandamos a <strong>localiza√ß√£o</strong> do arquivo original.</p>
            <p>A fun√ß√£o recebe o <strong>endere√ßo</strong> (ponteiro) e pode ir at√© l√° modificar o original.</p>
        </section>

        <!-- 12. Sintaxe na Fun√ß√£o -->
        <section class="slide">
            <h2>Recebendo um Ponteiro</h2>
            <p>Na fun√ß√£o, declaramos que vamos receber um endere√ßo usando o asterisco.</p>
            <pre><span class="tok-kw">void</span> zerar(<span class="tok-type">int</span> <span class="tok-ptr">*</span>p) {
    <span class="tok-ptr">*</span>p = <span class="tok-num">0</span>; <span class="tok-com">// Vai no endere√ßo e zera!</span>
}</pre>
        </section>

        <!-- 13. Sintaxe na Chamada -->
        <section class="slide">
            <h2>Enviando o Endere√ßo</h2>
            <p>Na hora de chamar a fun√ß√£o, usamos o <code class="inline-code">&</code> para enviar o endere√ßo da nossa vari√°vel.</p>
            <pre><span class="tok-type">int</span> vida = <span class="tok-num">100</span>;
zerar(<span class="tok-ptr">&</span>vida); <span class="tok-com">// "Toma aqui o endere√ßo da vida"</span></pre>
        </section>

        <!-- 14. DEPURADOR 2 -->
        <section class="slide" data-debug="func">
            <h2>Depurador: Ponteiros em Fun√ß√µes</h2>
            <p class="controls-help">Use a <strong>Seta Esquerda</strong> (‚Üê) para avan√ßar o passo a passo.</p>
            <div class="debugger-container mt-4">
                <div class="code-panel">
                    <pre id="code-func">
<span class="debug-line" data-l="1"><span class="tok-kw">void</span> <span class="tok-func">dobrar</span>(<span class="tok-type">int</span> <span class="tok-ptr">*</span>p) {</span>
<span class="debug-line" data-l="2">    <span class="tok-ptr">*</span>p = <span class="tok-ptr">*</span>p * <span class="tok-num">2</span>;</span>
<span class="debug-line" data-l="3">}</span>
<span class="debug-line" data-l="4"><span class="tok-type">int</span> main() {</span>
<span class="debug-line" data-l="5">    <span class="tok-type">int</span> num = <span class="tok-num">5</span>;</span>
<span class="debug-line" data-l="6">    <span class="tok-func">dobrar</span>(<span class="tok-ptr">&</span>num);</span>
<span class="debug-line" data-l="7">    <span class="tok-kw">return</span> <span class="tok-num">0</span>;</span>
<span class="debug-line" data-l="8">}</span>
                    </pre>
                </div>
                <div class="memory-panel" id="mem-func"></div>
            </div>
        </section>

        <!-- 15. Vetores s√£o Ponteiros? -->
        <section class="slide">
            <h2>Vetores e Ponteiros: O Segredo</h2>
            <p>Voc√™s sabiam que o nome de um vetor √©, na verdade, um ponteiro disfar√ßado?</p>
            <p class="font-bold text-2xl text-slate-800 mt-4">O nome do vetor √© o endere√ßo do primeiro item.</p>
            <pre><span class="tok-type">int</span> v[<span class="tok-num">3</span>] = {<span class="tok-num">10</span>, <span class="tok-num">20</span>, <span class="tok-num">30</span>};
<span class="tok-com">// 'v' √© igual a &v[0]</span></pre>
        </section>

        <!-- 16. Aritm√©tica de Ponteiros -->
        <section class="slide">
            <h2>Aritm√©tica de Ponteiros</h2>
            <p>Ponteiros s√£o inteligentes. Se voc√™ somar <code class="inline-code">+ 1</code> a um ponteiro de inteiro, ele n√£o pula 1 byte.</p>
            <p>Ele pula <strong>1 gaveta inteira</strong> (4 bytes) e cai exatamente no pr√≥ximo n√∫mero do vetor.</p>
            <div class="analogy">
                <span class="analogy-icon">‚è≠Ô∏è</span>
                <p><strong>ptr + 1</strong> = "V√° para a casa vizinha".</p>
            </div>
        </section>

        <!-- 17. Acessando Vetores -->
        <section class="slide">
            <h2>Duas formas de Acesso</h2>
            <p>Podemos acessar um vetor de duas formas que, no fundo, s√£o iguais:</p>
            <ul class="list-disc text-left text-xl mt-4 pl-8">
                <li><strong>√çndice:</strong> <code class="inline-code">vetor[i]</code> (O jeito cl√°ssico)</li>
                <li><strong>Ponteiro:</strong> <code class="inline-code">*(vetor + i)</code> (O jeito hacker)</li>
            </ul>
        </section>

        <!-- 18. DEPURADOR 3 -->
        <section class="slide" data-debug="arr">
            <h2>Depurador: Vetores e Ponteiros</h2>
            <p class="controls-help">Use a <strong>Seta Esquerda</strong> (‚Üê) para avan√ßar o passo a passo.</p>
            <div class="debugger-container mt-4">
                <div class="code-panel">
                    <pre id="code-arr">
<span class="debug-line" data-l="1"><span class="tok-type">int</span> main() {</span>
<span class="debug-line" data-l="2">    <span class="tok-type">int</span> v[<span class="tok-num">3</span>] = {<span class="tok-num">10</span>, <span class="tok-num">20</span>, <span class="tok-num">30</span>};</span>
<span class="debug-line" data-l="3">    <span class="tok-type">int</span> <span class="tok-ptr">*</span>p = v;</span>
<span class="debug-line" data-l="4">    <span class="tok-ptr">*</span>p = <span class="tok-num">99</span>;</span>
<span class="debug-line" data-l="5">    p++; <span class="tok-com">// Avan√ßa p/ v[1]</span></span>
<span class="debug-line" data-l="6">    <span class="tok-ptr">*</span>p = <span class="tok-num">88</span>;</span>
<span class="debug-line" data-l="7">    <span class="tok-kw">return</span> <span class="tok-num">0</span>;</span>
<span class="debug-line" data-l="8">}</span>
                    </pre>
                </div>
                <div class="memory-panel" id="mem-arr"></div>
            </div>
        </section>

        <!-- 19. Mem√≥ria Din√¢mica -->
        <section class="slide">
            <h2>O Problema dos Vetores Fixos</h2>
            <p>At√© hoje, precis√°vamos saber o tamanho do vetor antes de compilar: <code class="inline-code">int v[10];</code>.</p>
            <p>E se quisermos criar um vetor cujo tamanho s√≥ saberemos quando o programa estiver rodando? (Ex: usu√°rio digita a quantidade de alunos).</p>
        </section>

        <!-- 20. Malloc: Pedindo Mem√≥ria -->
        <section class="slide">
            <h2>malloc: Pedindo Espa√ßo</h2>
            <p><code class="inline-code">malloc</code> (Memory Allocation) √© uma fun√ß√£o que pede ao sistema operacional um peda√ßo de mem√≥ria "na hora".</p>
            <div class="analogy">
                <span class="analogy-icon">üèóÔ∏è</span>
                <p><strong>malloc(tamanho)</strong><br>"Ei computador, me arruma um terreno desse tamanho a√≠?"</p>
            </div>
        </section>

        <!-- 21. Usando o malloc -->
        <section class="slide">
            <h2>Sintaxe do malloc</h2>
            <p>Como o <code class="inline-code">malloc</code> devolve um endere√ßo, precisamos de um ponteiro para guard√°-lo.</p>
            <pre><span class="tok-type">int</span> <span class="tok-ptr">*</span>vetor;
<span class="tok-com">// Quero espa√ßo para 5 inteiros</span>
vetor = (<span class="tok-type">int</span>*) <span class="tok-func">malloc</span>(<span class="tok-num">5</span> * <span class="tok-kw">sizeof</span>(<span class="tok-type">int</span>));</pre>
        </section>

        <!-- 22. A Import√¢ncia do Free -->
        <section class="slide">
            <h2>free: Devolvendo o Espa√ßo</h2>
            <p>Mem√≥ria alocada manualmente n√£o se limpa sozinha! Se voc√™ n√£o devolver, o programa consome toda a RAM (Memory Leak).</p>
            <div class="analogy">
                <span class="analogy-icon">üßπ</span>
                <p><strong>free(ponteiro)</strong><br>"Terminei de usar esse terreno. Pode pegar de volta."</p>
            </div>
        </section>

        <!-- 23. DEPURADOR 4 -->
        <section class="slide" data-debug="malloc">
            <h2>Depurador: Aloca√ß√£o Din√¢mica</h2>
            <p class="controls-help">Use a <strong>Seta Esquerda</strong> (‚Üê) para avan√ßar o passo a passo.</p>
            <div class="debugger-container mt-4">
                <div class="code-panel">
                    <pre id="code-malloc">
<span class="debug-line" data-l="1"><span class="tok-type">int</span> main() {</span>
<span class="debug-line" data-l="2">    <span class="tok-type">int</span> <span class="tok-ptr">*</span>p;</span>
<span class="debug-line" data-l="3">    p = <span class="tok-func">malloc</span>(<span class="tok-num">2</span> * <span class="tok-kw">sizeof</span>(<span class="tok-type">int</span>));</span>
<span class="debug-line" data-l="4">    p[<span class="tok-num">0</span>] = <span class="tok-num">10</span>;</span>
<span class="debug-line" data-l="5">    p[<span class="tok-num">1</span>] = <span class="tok-num">20</span>;</span>
<span class="debug-line" data-l="6">    <span class="tok-func">free</span>(p);</span>
<span class="debug-line" data-l="7">    p = <span class="tok-kw">NULL</span>;</span>
<span class="debug-line" data-l="8">}</span>
                    </pre>
                </div>
                <div class="memory-panel" id="mem-malloc"></div>
            </div>
        </section>

        <!-- 24. Ponteiros Gen√©ricos -->
        <section class="slide">
            <h2>Ponteiros void* (Gen√©ricos)</h2>
            <p>√Äs vezes queremos um ponteiro que possa apontar para <strong>qualquer coisa</strong> (int, float, char, struct...).</p>
            <p>Para isso existe o <code class="inline-code">void *</code>.</p>
            <div class="analogy">
                <span class="analogy-icon">üì¶</span>
                <p><strong>void *</strong> √© uma "Caixa Misteriosa". Ela guarda um endere√ßo, mas n√£o dizemos o que tem l√° dentro.</p>
            </div>
        </section>

        <!-- 25. Usando void* -->
        <section class="slide">
            <h2>A Regra do void*</h2>
            <p>Voc√™ n√£o pode acessar o valor de um <code class="inline-code">void *</code> diretamente, porque o computador n√£o sabe o tamanho do dado.</p>
            <p>Voc√™ precisa fazer um <strong>CAST</strong> (convers√£o) antes de usar, dizendo: "Eu juro que aqui dentro tem um int!".</p>
            <pre><span class="tok-kw">void</span> *generico;
<span class="tok-type">int</span> num = <span class="tok-num">10</span>;
generico = &num;

<span class="tok-com">// printf("%d", *generico); // ERRO!</span>
<span class="tok-func">printf</span>(<span class="tok-str">"%d"</span>, *(<span class="tok-type">int</span>*)generico); <span class="tok-com">// Certo!</span></pre>
        </section>

        <!-- 26. DEPURADOR 5 -->
        <section class="slide" data-debug="void">
            <h2>Depurador: Ponteiro Void</h2>
            <p class="controls-help">Use a <strong>Seta Esquerda</strong> (‚Üê) para avan√ßar o passo a passo.</p>
            <div class="debugger-container mt-4">
                <div class="code-panel">
                    <pre id="code-void">
<span class="debug-line" data-l="1"><span class="tok-type">int</span> main() {</span>
<span class="debug-line" data-l="2">    <span class="tok-type">int</span> a = <span class="tok-num">5</span>;</span>
<span class="debug-line" data-l="3">    <span class="tok-type">float</span> b = <span class="tok-num">2.5</span>;</span>
<span class="debug-line" data-l="4">    <span class="tok-kw">void</span> <span class="tok-ptr">*</span>gen;</span>
<span class="debug-line" data-l="5">    gen = <span class="tok-ptr">&</span>a;</span>
<span class="debug-line" data-l="6">    <span class="tok-com">// L√™ como int</span></span>
<span class="debug-line" data-l="7">    gen = <span class="tok-ptr">&</span>b;</span>
<span class="debug-line" data-l="8">    <span class="tok-com">// L√™ como float</span></span>
<span class="debug-line" data-l="9">}</span>
                    </pre>
                </div>
                <div class="memory-panel" id="mem-void"></div>
            </div>
        </section>

        <!-- 27. Resumo Final -->
        <section class="slide">
            <h2>Parab√©ns! Voc√™ Dominou Ponteiros üéâ</h2>
            <ul class="text-left text-xl space-y-4 list-disc">
                <li><strong>Ponteiros:</strong> Vari√°veis que guardam endere√ßos.</li>
                <li><strong>Passagem por Refer√™ncia:</strong> Permite que fun√ß√µes alterem vari√°veis originais.</li>
                <li><strong>Vetores:</strong> S√£o ponteiros para o primeiro elemento.</li>
                <li><strong>Malloc/Free:</strong> Gerenciamento manual de mem√≥ria.</li>
                <li><strong>Void*:</strong> Ponteiros que apontam para qualquer tipo.</li>
            </ul>
        </section>

    </main>

    <script>
        // NAVEGA√á√ÉO
        const sections = document.querySelectorAll('section');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const counterDiv = document.getElementById('counter');
        let currentSlide = 0;

        function updateCounter() {
            counterDiv.innerText = (currentSlide + 1) + ' / ' + sections.length;
        }

        function goToSlide(index) {
            if (index >= 0 && index < sections.length) {
                currentSlide = index;
                sections[index].scrollIntoView({ behavior: 'smooth' });
                updateCounter();
                
                // Reset debuggers if entering a debug slide
                if (sections[index].hasAttribute('data-debug')) {
                    const type = sections[index].getAttribute('data-debug');
                    resetDebugger(type);
                }
            }
        }

        // CONTROLES DE TECLADO E CLIQUE
        // Seta Direita: Sempre Pr√≥ximo Slide
        // Seta Esquerda: 
        //    - Se em slide de debug e n√£o terminou: Avan√ßa passo
        //    - Se em slide normal ou terminou debug: Slide Anterior

        prevBtn.addEventListener('click', () => goToSlide(currentSlide - 1));
        nextBtn.addEventListener('click', () => goToSlide(currentSlide + 1));

        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowRight') {
                e.preventDefault();
                goToSlide(currentSlide + 1);
            } else if (e.key === 'ArrowLeft') {
                e.preventDefault();
                
                const debugType = sections[currentSlide].getAttribute('data-debug');
                
                if (debugType && !isDebuggerFinished(debugType)) {
                    // Se √© slide de debug e ainda tem passos, avan√ßa o passo
                    stepDebugger(debugType);
                } else {
                    // Sen√£o, volta o slide
                    goToSlide(currentSlide - 1);
                }
            }
        });

        // INTERSECTION OBSERVER PARA ATUALIZAR CONTADOR AO ROLAR
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if(entry.isIntersecting) {
                    // Encontrar index
                    for(let i=0; i<sections.length; i++) {
                        if(sections[i] === entry.target) {
                            currentSlide = i;
                            updateCounter();
                            break;
                        }
                    }
                }
            });
        }, { threshold: 0.5 });

        sections.forEach(sec => observer.observe(sec));
        updateCounter();


        // L√ìGICA DOS DEPURADORES
        // Estados e Passos
        // Definindo sequencia de linhas e estados de mem√≥ria para cada debugger
        
        const debugData = {
            'basic': [
                { line: 1, mem: [] },
                { line: 2, mem: [{addr:'0x100', name:'a', val:'10', changed:true}] },
                { line: 3, mem: [{addr:'0x100', name:'a', val:'10'}, {addr:'0x104', name:'ptr', val:'?'}] },
                { line: 4, mem: [{addr:'0x100', name:'a', val:'10'}, {addr:'0x104', name:'ptr', val:'0x100', changed:true}] },
                { line: 5, mem: [{addr:'0x100', name:'a', val:'20', changed:true}, {addr:'0x104', name:'ptr', val:'0x100'}] },
                { line: 6, mem: [{addr:'0x100', name:'a', val:'20'}, {addr:'0x104', name:'ptr', val:'0x100'}] },
                { line: 7, mem: [{addr:'0x100', name:'a', val:'20'}, {addr:'0x104', name:'ptr', val:'0x100'}] }
            ],
            'func': [
                { line: 4, mem: [] },
                { line: 5, mem: [{addr:'0xF00', name:'num', val:'5', changed:true}] },
                { line: 6, mem: [{addr:'0xF00', name:'num', val:'5'}], mark: 6 }, // Call
                { line: 1, mem: [{addr:'0xF00', name:'num', val:'5'}, {addr:'0xFF0', name:'p', val:'0xF00', changed:true}] }, // Inside Func
                { line: 2, mem: [{addr:'0xF00', name:'num', val:'10', changed:true}, {addr:'0xFF0', name:'p', val:'0xF00'}] }, // Modified via pointer
                { line: 3, mem: [{addr:'0xF00', name:'num', val:'10'}, {addr:'0xFF0', name:'p', val:'0xF00'}] }, // End Func
                { line: 6, mem: [{addr:'0xF00', name:'num', val:'10'}] }, // Back to Call
                { line: 7, mem: [{addr:'0xF00', name:'num', val:'10'}] },
                { line: 8, mem: [{addr:'0xF00', name:'num', val:'10'}] }
            ],
            'arr': [
                { line: 1, mem: [] },
                { line: 2, mem: [{addr:'0xA0', name:'v[0]', val:'10', changed:true}, {addr:'0xA4', name:'v[1]', val:'20', changed:true}, {addr:'0xA8', name:'v[2]', val:'30', changed:true}] },
                { line: 3, mem: [{addr:'0xA0', name:'v[0]', val:'10'}, {addr:'0xA4', name:'v[1]', val:'20'}, {addr:'0xA8', name:'v[2]', val:'30'}, {addr:'0xB0', name:'p', val:'0xA0', changed:true}] },
                { line: 4, mem: [{addr:'0xA0', name:'v[0]', val:'99', changed:true}, {addr:'0xA4', name:'v[1]', val:'20'}, {addr:'0xA8', name:'v[2]', val:'30'}, {addr:'0xB0', name:'p', val:'0xA0'}] },
                { line: 5, mem: [{addr:'0xA0', name:'v[0]', val:'99'}, {addr:'0xA4', name:'v[1]', val:'20'}, {addr:'0xA8', name:'v[2]', val:'30'}, {addr:'0xB0', name:'p', val:'0xA4', changed:true}] }, // p++
                { line: 6, mem: [{addr:'0xA0', name:'v[0]', val:'99'}, {addr:'0xA4', name:'v[1]', val:'88', changed:true}, {addr:'0xA8', name:'v[2]', val:'30'}, {addr:'0xB0', name:'p', val:'0xA4'}] },
                { line: 7, mem: [] },
                { line: 8, mem: [] }
            ],
            'malloc': [
                { line: 1, mem: [] },
                { line: 2, mem: [{addr:'STK', name:'p', val:'?'}] },
                { line: 3, mem: [{addr:'STK', name:'p', val:'HEAP', changed:true}, {addr:'HEAP', name:'[0]', val:'?', changed:true}, {addr:'HEAP+4', name:'[1]', val:'?', changed:true}] },
                { line: 4, mem: [{addr:'STK', name:'p', val:'HEAP'}, {addr:'HEAP', name:'[0]', val:'10', changed:true}, {addr:'HEAP+4', name:'[1]', val:'?'}] },
                { line: 5, mem: [{addr:'STK', name:'p', val:'HEAP'}, {addr:'HEAP', name:'[0]', val:'10'}, {addr:'HEAP+4', name:'[1]', val:'20', changed:true}] },
                { line: 6, mem: [{addr:'STK', name:'p', val:'HEAP'}, {addr:'----', name:'(Free)', val:'-', changed:true}] }, // Free
                { line: 7, mem: [{addr:'STK', name:'p', val:'NULL', changed:true}] },
                { line: 8, mem: [] }
            ],
            'void': [
                { line: 1, mem: [] },
                { line: 2, mem: [{addr:'0xA0', name:'a', val:'5', changed:true}] },
                { line: 3, mem: [{addr:'0xA0', name:'a', val:'5'}, {addr:'0xA4', name:'b', val:'2.5', changed:true}] },
                { line: 4, mem: [{addr:'0xA0', name:'a', val:'5'}, {addr:'0xA4', name:'b', val:'2.5'}, {addr:'0xB0', name:'gen', val:'?'}] },
                { line: 5, mem: [{addr:'0xA0', name:'a', val:'5'}, {addr:'0xA4', name:'b', val:'2.5'}, {addr:'0xB0', name:'gen', val:'0xA0', changed:true}] },
                { line: 6, mem: [{addr:'0xA0', name:'a', val:'5'}, {addr:'0xA4', name:'b', val:'2.5'}, {addr:'0xB0', name:'gen', val:'0xA0'}] }, // print int
                { line: 7, mem: [{addr:'0xA0', name:'a', val:'5'}, {addr:'0xA4', name:'b', val:'2.5'}, {addr:'0xB0', name:'gen', val:'0xA4', changed:true}] },
                { line: 8, mem: [{addr:'0xA0', name:'a', val:'5'}, {addr:'0xA4', name:'b', val:'2.5'}, {addr:'0xB0', name:'gen', val:'0xA4'}] }, // print float
                { line: 9, mem: [] }
            ]
        };

        const currentSteps = {};

        function resetDebugger(type) {
            currentSteps[type] = 0;
            renderDebugger(type);
        }

        function isDebuggerFinished(type) {
            if (!debugData[type]) return true;
            return currentSteps[type] >= debugData[type].length - 1;
        }

        function stepDebugger(type) {
            if (!debugData[type]) return;
            if (currentSteps[type] < debugData[type].length - 1) {
                currentSteps[type]++;
                renderDebugger(type);
            }
        }

        function renderDebugger(type) {
            const state = debugData[type][currentSteps[type]];
            const container = document.querySelector(`[data-debug="${type}"]`);
            if (!container) return;

            // Atualizar C√≥digo
            container.querySelectorAll('.debug-line').forEach(line => {
                line.classList.remove('active');
                line.classList.remove('call-site');
            });

            const currentLineEl = container.querySelector(`.debug-line[data-l="${state.line}"]`);
            if (currentLineEl) currentLineEl.classList.add('active');

            // Marcar Call Site se necess√°rio (l√≥gica simples para o exemplo 'func')
            // No slide 'func', a chamada ocorre na linha 6. Se estivermos nas linhas 1, 2 ou 3, a linha 6 √© o call site.
            if (type === 'func' && (state.line >= 1 && state.line <= 3)) {
                const callLine = container.querySelector(`.debug-line[data-l="6"]`);
                if (callLine) callLine.classList.add('call-site');
            }

            // Atualizar Mem√≥ria
            const memPanel = container.querySelector('.memory-panel');
            memPanel.innerHTML = '';
            if (state.mem) {
                state.mem.forEach(m => {
                    const box = document.createElement('div');
                    box.className = `mem-box ${m.changed ? 'changed' : ''}`;
                    box.innerHTML = `
                        <div class="mem-addr">${m.addr}</div>
                        <div class="mem-name">${m.name}</div>
                        <div class="mem-val">${m.val}</div>
                    `;
                    memPanel.appendChild(box);
                });
            }
        }

        // Inicializar o estado dos debuggers no zero
        Object.keys(debugData).forEach(type => currentSteps[type] = 0);

    </script>
</body>
</html>