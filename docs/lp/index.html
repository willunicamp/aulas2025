<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prof. William Paiva - 2025 - COTIL</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Estilo para garantir que a página ocupe toda a tela, sem margens */
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden; /* Evita barras de rolagem */
            height: 100%;
            font-family: 'Roboto Mono', monospace;
            background-color: #eef2f7; /* Tom de branco levemente azulado */
        }

        /* O canvas ocupará toda a área visível */
        #interactiveCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        /* Título posicionado sobre o canvas */
        .overlay-title {
            position: absolute;
            top: 5%;
            left: 50%;
            transform: translateX(-50%);
            color: #4a5568; /* Cor de texto escura e suave */
            font-size: 2.5em;
            font-weight: 700;
            text-align: center;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.9);
            pointer-events: none; /* Permite que cliques "atravessem" o título e cheguem ao canvas */
        }
        
        /* Ajuste de fonte para telas menores */
        @media (max-width: 768px) {
            .overlay-title {
                font-size: 1.8em;
                width: 90%;
            }
        }
    </style>
</head>
<body>
    <!-- Título da página que fica por cima do canvas -->
    <h1 class="overlay-title">Prof. William Paiva - 2025 - COTIL</h1>
    
    <!-- O elemento canvas onde tudo será desenhado -->
    <canvas id="interactiveCanvas"></canvas>

    <script>
// --- CONFIGURAÇÃO INICIAL ---
const canvas = document.getElementById('interactiveCanvas');
const ctx = canvas.getContext('2d');

let classes = []; // A lista agora começa vazia
let buttons = [];
let mouse = { x: undefined, y: undefined };

// --- FUNÇÃO PARA CARREGAR A CONFIGURAÇÃO ---
async function loadConfig() {
    try {
        const response = await fetch('./config.json'); // Carrega o arquivo JSON
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        classes = await response.json(); // Preenche a lista de turmas
        init(); // Inicializa a página APÓS carregar os dados
        animate();
    } catch (error) {
        console.error("Não foi possível carregar o arquivo de configuração 'config.json':", error);
        // Exibe uma mensagem de erro no canvas se o arquivo não for encontrado
        ctx.fillStyle = '#4a5568';
        ctx.font = '16px "Roboto Mono"';
        ctx.textAlign = 'center';
        ctx.fillText("Erro: Não foi possível carregar 'config.json'.", canvas.width / 2, canvas.height / 2);
    }
}

// --- FUNÇÃO AUXILIAR PARA DESENHAR RETÂNGULOS ARREDONDADOS ---
function drawRoundedRect(ctx, x, y, width, height, radius) {
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x + width - radius, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
    ctx.lineTo(x + width, y + height - radius);
    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    ctx.lineTo(x + radius, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.closePath();
}

// --- CLASSE PARA OS BOTÕES ---
class Button {
    constructor(x, y, width, height, text, link) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.text = text;
        this.link = link;
        
        this.scale = 1;
        this.targetScale = 1;
        this.shadowBlur = 15;
        this.targetShadowBlur = 15;
        
        this.borderColor = '#d1d9e6';
        this.textColor = '#4a5568';
    }

    update() {
        this.scale += (this.targetScale - this.scale) * 0.1;
        this.shadowBlur += (this.targetShadowBlur - this.shadowBlur) * 0.1;
    }

    draw() {
        this.update();

        const scaledWidth = this.width * this.scale;
        const scaledHeight = this.height * this.scale;
        const scaledX = this.x - (scaledWidth - this.width) / 2;
        const scaledY = this.y - (scaledHeight - this.height) / 2;

        ctx.save();
        
        ctx.shadowColor = 'rgba(163, 177, 198, 0.6)';
        ctx.shadowBlur = this.shadowBlur;
        ctx.shadowOffsetX = 5;
        ctx.shadowOffsetY = 5;

        const gradient = ctx.createLinearGradient(scaledX, scaledY, scaledX, scaledY + scaledHeight);
        gradient.addColorStop(0, '#fdfdff');
        gradient.addColorStop(1, '#e8edf3');
        ctx.fillStyle = gradient;

        drawRoundedRect(ctx, scaledX, scaledY, scaledWidth, scaledHeight, 20);
        ctx.fill();
        
        ctx.restore();
        
        ctx.fillStyle = this.textColor;
        ctx.font = 'bold 16px "Roboto Mono"';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.text, this.x + this.width / 2, this.y + this.height / 2);
    }

    isMouseOver(mouseX, mouseY) {
        return mouseX > this.x && mouseX < this.x + this.width &&
               mouseY > this.y && mouseY < this.y + this.height;
    }
}

// --- FUNÇÕES DE CONTROLE ---
function init() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    buttons = [];

    if (classes.length === 0) return; // Não faz nada se não houver turmas

    const isMobile = canvas.width < 768;
    const columns = isMobile ? 2 : 4;
    const rows = Math.ceil(classes.length / columns);

    const cardWidth = 200;
    const cardHeight = 80;
    const gapX = 40;
    const gapY = 40;

    const totalGridWidth = (columns * cardWidth) + ((columns - 1) * gapX);
    const totalGridHeight = (rows * cardHeight) + ((rows - 1) * gapY);

    const startX = (canvas.width - totalGridWidth) / 2;
    const startY = (canvas.height - totalGridHeight) / 2 + 50;

    let classIndex = 0;
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < columns; c++) {
            if (classIndex < classes.length) {
                const x = startX + c * (cardWidth + gapX);
                const y = startY + r * (cardHeight + gapY);
                const classInfo = classes[classIndex];
                buttons.push(new Button(x, y, cardWidth, cardHeight, classInfo.text, classInfo.link));
                classIndex++;
            }
        }
    }
}

function animate() {
    requestAnimationFrame(animate);

    ctx.fillStyle = '#eef2f7';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    buttons.forEach(button => {
        button.draw();
    });
}

// --- EVENT LISTENERS ---
window.addEventListener('mousemove', (event) => {
    mouse.x = event.clientX;
    mouse.y = event.clientY;

    let isOverAnyButton = false;
    buttons.forEach(button => {
        if (button.isMouseOver(mouse.x, mouse.y)) {
            button.targetScale = 1.05;
            button.targetShadowBlur = 25;
            isOverAnyButton = true;
        } else {
            button.targetScale = 1;
            button.targetShadowBlur = 15;
        }
    });
    
    document.body.style.cursor = isOverAnyButton ? 'pointer' : 'default';
});

window.addEventListener('click', (event) => {
    buttons.forEach(button => {
        if (button.isMouseOver(event.clientX, event.clientY)) {
            window.location.href = button.link;
        }
    });
});

window.addEventListener('resize', init);

// --- INICIALIZAÇÃO ---
loadConfig(); // A mágica começa aqui!
    </script>
</body>
</html>
