<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Criador de Diagrama de Classes</title>
    <!-- Tailwind CSS via CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom styles for the draggable class boxes */
        .class-box {
            position: absolute;
            cursor: move;
            user-select: none;
            min-width: 200px;
            max-width: 400px;
        }
        .class-box-header {
            font-weight: bold;
            text-align: center;
        }
        .class-box-content {
            font-family: monospace;
            text-align: left;
        }
        /* Prevents text selection while dragging */
        .dragging {
            cursor: grabbing;
        }
        .connection-line {
            stroke: #4a5568;
            stroke-width: 2;
        }
        .dark .connection-line {
            stroke: #a0aec0;
        }
        .connecting .class-box {
            cursor: crosshair;
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-gray-100 flex h-screen overflow-hidden">

    <!-- Painel de Controle (Sidebar) -->
    <aside class="w-80 bg-white dark:bg-gray-800 p-6 shadow-lg flex flex-col flex-shrink-0">
        <div class="flex items-center mb-6">
            <svg class="w-8 h-8 text-indigo-500 mr-3" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 4a2 2 0 114 0v1a1 1 0 001 1h3a1 1 0 011 1v3a1 1 0 01-1 1h-1a2 2 0 100 4h1a1 1 0 011 1v3a1 1 0 01-1 1h-3a1 1 0 01-1-1v-1a2 2 0 10-4 0v1a1 1 0 01-1 1H7a1 1 0 01-1-1v-3a1 1 0 011-1h1a2 2 0 100-4H7a1 1 0 01-1-1V7a1 1 0 011-1h3a1 1 0 001-1V4z"></path></svg>
            <h1 class="text-xl font-bold">Diagrama de Classes</h1>
        </div>
        
        <div class="space-y-4 flex-grow">
            <div>
                <label for="className" class="block text-sm font-medium text-gray-700 dark:text-gray-300">Nome da Classe</label>
                <input type="text" id="className" class="mt-1 block w-full bg-gray-50 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm" placeholder="Ex: Usuario">
            </div>
            <div>
                <label for="attributes" class="block text-sm font-medium text-gray-700 dark:text-gray-300">Atributos</label>
                <textarea id="attributes" rows="5" class="mt-1 block w-full bg-gray-50 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm" placeholder="- nome: string&#10;- email: string"></textarea>
                 <p class="mt-1 text-xs text-gray-500">Um atributo por linha.</p>
            </div>
            <div>
                <label for="methods" class="block text-sm font-medium text-gray-700 dark:text-gray-300">Métodos</label>
                <textarea id="methods" rows="5" class="mt-1 block w-full bg-gray-50 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm" placeholder="+ login(): void&#10;+ logout(): void"></textarea>
                <p class="mt-1 text-xs text-gray-500">Um método por linha.</p>
            </div>
            <button id="addClassBtn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-md transition duration-300 ease-in-out focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                Adicionar Classe
            </button>
        </div>
        
        <!-- Seção de Relacionamentos -->
        <div class="mt-6 pt-6 border-t border-gray-200 dark:border-gray-700">
             <h2 class="text-lg font-semibold mb-3">Relacionamentos</h2>
             <div class="grid grid-cols-2 gap-2">
                <button data-type="inheritance" class="relationship-btn bg-gray-200 dark:bg-gray-700 hover:bg-indigo-200 dark:hover:bg-indigo-800 text-sm font-medium py-2 px-3 rounded-md transition">Herança</button>
                <button data-type="composition" class="relationship-btn bg-gray-200 dark:bg-gray-700 hover:bg-indigo-200 dark:hover:bg-indigo-800 text-sm font-medium py-2 px-3 rounded-md transition">Composição</button>
                <button data-type="aggregation" class="relationship-btn bg-gray-200 dark:bg-gray-700 hover:bg-indigo-200 dark:hover:bg-indigo-800 text-sm font-medium py-2 px-3 rounded-md transition">Agregação</button>
                <button data-type="association" class="relationship-btn bg-gray-200 dark:bg-gray-700 hover:bg-indigo-200 dark:hover:bg-indigo-800 text-sm font-medium py-2 px-3 rounded-md transition">Associação</button>
             </div>
        </div>


        <button id="clearBtn" class="w-full mt-4 bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-md transition duration-300 ease-in-out focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500">
            Limpar Diagrama
        </button>
    </aside>

    <!-- Área do Diagrama (Canvas) -->
    <main id="diagram-canvas" class="flex-1 bg-gray-200 dark:bg-gray-900/50 relative overflow-hidden">
        <!-- SVG para desenhar as linhas de conexão -->
        <svg id="connector-svg" class="absolute top-0 left-0 w-full h-full pointer-events-none">
            <defs>
                <!-- Seta para Herança (triângulo vazio) -->
                <marker id="arrow-inheritance" viewBox="0 0 10 10" refX="8" refY="5" markerWidth="6" markerHeight="6" orient="auto">
                    <path d="M 0 0 L 10 5 L 0 10 z" fill="none" stroke="currentColor" stroke-width="2"></path>
                </marker>
                <!-- Seta para Composição (losango preenchido) -->
                 <marker id="arrow-composition" viewBox="0 0 12 12" refX="10" refY="6" markerWidth="8" markerHeight="8" orient="auto">
                    <path d="M 6 0 L 12 6 L 6 12 L 0 6 z" fill="currentColor"></path>
                </marker>
                <!-- Seta para Agregação (losango vazio) -->
                <marker id="arrow-aggregation" viewBox="0 0 12 12" refX="10" refY="6" markerWidth="8" markerHeight="8" orient="auto">
                    <path d="M 6 0 L 12 6 L 6 12 L 0 6 z" fill="none" stroke="currentColor" stroke-width="2"></path>
                </marker>
            </defs>
        </svg>
        <!-- As classes serão adicionadas aqui via JavaScript -->
    </main>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Elementos do DOM ---
            const canvas = document.getElementById('diagram-canvas');
            const svgCanvas = document.getElementById('connector-svg');
            const addClassBtn = document.getElementById('addClassBtn');
            const clearBtn = document.getElementById('clearBtn');
            const classNameInput = document.getElementById('className');
            const attributesInput = document.getElementById('attributes');
            const methodsInput = document.getElementById('methods');
            const relationshipBtns = document.querySelectorAll('.relationship-btn');

            // --- Estado para arrastar e soltar ---
            let activeElement = null;
            let offsetX = 0;
            let offsetY = 0;
            
            // --- Contador para z-index ---
            let highestZIndex = 0;
            
            // --- Estado para conexões ---
            let connectionMode = null; // 'inheritance', 'composition', etc.
            let firstNode = null;
            let connections = [];


            // --- Funções ---

            /**
             * Cria e adiciona uma nova caixa de classe ao canvas.
             */
            const createClass = () => {
                const name = classNameInput.value.trim() || 'NovaClasse';
                const attributes = attributesInput.value.trim().split('\n').filter(line => line.trim() !== '');
                const methods = methodsInput.value.trim().split('\n').filter(line => line.trim() !== '');

                // Cria o elemento da caixa
                const classBox = document.createElement('div');
                classBox.className = 'class-box bg-white dark:bg-gray-800 rounded-lg shadow-xl border border-gray-300 dark:border-gray-700 overflow-hidden';
                classBox.dataset.id = `class-${Date.now()}-${Math.random()}`;
                
                // Posicionamento inicial aleatório
                const canvasRect = canvas.getBoundingClientRect();
                const x = Math.random() * (canvasRect.width - 250) + 20;
                const y = Math.random() * (canvasRect.height - 200) + 20;
                classBox.style.left = `${x}px`;
                classBox.style.top = `${y}px`;

                // Cabeçalho com o nome da classe
                const header = document.createElement('div');
                header.className = 'class-box-header p-3 bg-gray-100 dark:bg-gray-700';
                header.textContent = name;
                classBox.appendChild(header);

                // Seção de atributos
                if (attributes.length > 0) {
                    const attributesSection = document.createElement('div');
                    attributesSection.className = 'class-box-content p-3 border-t border-gray-200 dark:border-gray-600';
                    attributes.forEach(attr => {
                        const p = document.createElement('p');
                        p.textContent = attr;
                        attributesSection.appendChild(p);
                    });
                    classBox.appendChild(attributesSection);
                }

                // Seção de métodos
                if (methods.length > 0) {
                    const methodsSection = document.createElement('div');
                    methodsSection.className = 'class-box-content p-3 border-t border-gray-200 dark:border-gray-600';
                    methods.forEach(method => {
                        const p = document.createElement('p');
                        p.textContent = method;
                        methodsSection.appendChild(p);
                    });
                    classBox.appendChild(methodsSection);
                }
                
                // Adiciona eventos de arrastar
                classBox.addEventListener('mousedown', onMouseDown);
                // Adiciona evento de clique para conexões
                classBox.addEventListener('click', handleConnectionClick);
                
                // Adiciona ao canvas e limpa os inputs
                canvas.appendChild(classBox);
                classNameInput.value = '';
                attributesInput.value = '';
                methodsInput.value = '';
                classNameInput.focus();
            };

            /**
             * Limpa todos os elementos do canvas.
             */
            const clearCanvas = () => {
                canvas.querySelectorAll('.class-box').forEach(box => box.remove());
                svgCanvas.innerHTML = svgCanvas.querySelector('defs').outerHTML; // Mantém as defs
                connections = [];
                highestZIndex = 0;
                resetConnectionMode();
            };

            // --- Funções de Conexão ---

            /**
             * Calcula os pontos de início e fim de uma conexão nas bordas das caixas.
             * @param {HTMLElement} fromNode 
             * @param {HTMLElement} toNode 
             * @returns {{startPoint: {x, y}, endPoint: {x, y}}}
             */
            function calculateConnectionPoints(fromNode, toNode) {
                const fromRect = fromNode.getBoundingClientRect();
                const toRect = toNode.getBoundingClientRect();
                const canvasRect = canvas.getBoundingClientRect();

                const fromCenter = {
                    x: fromRect.left + fromRect.width / 2 - canvasRect.left,
                    y: fromRect.top + fromRect.height / 2 - canvasRect.top
                };
                const toCenter = {
                    x: toRect.left + toRect.width / 2 - canvasRect.left,
                    y: toRect.top + toRect.height / 2 - canvasRect.top
                };

                const dx = toCenter.x - fromCenter.x;
                const dy = toCenter.y - fromCenter.y;

                // Função auxiliar para encontrar o ponto de interseção na borda de uma caixa
                const getIntersection = (center, rect, dx_orig, dy_orig) => {
                    const halfWidth = rect.width / 2;
                    const halfHeight = rect.height / 2;
                    
                    // Lida com linhas perfeitamente verticais ou horizontais para evitar divisão por zero
                    if (Math.abs(dx_orig) < 0.0001) {
                        const sign = dy_orig > 0 ? 1 : -1;
                        return { x: center.x, y: center.y - sign * halfHeight };
                    } 
                    if (Math.abs(dy_orig) < 0.0001) {
                        const sign = dx_orig > 0 ? 1 : -1;
                        return { x: center.x - sign * halfWidth, y: center.y };
                    }
                    
                    // Compara a proporção do vetor com a proporção da caixa para ver qual lado é cruzado
                    const xRatio = Math.abs(dx_orig) / halfWidth;
                    const yRatio = Math.abs(dy_orig) / halfHeight;

                    if (xRatio > yRatio) {
                        // Interseção com um lado vertical (esquerda/direita)
                        const sign = dx_orig > 0 ? 1 : -1;
                        return {
                            x: center.x - sign * halfWidth,
                            y: center.y - sign * halfWidth * (dy_orig / dx_orig)
                        };
                    } else {
                        // Interseção com um lado horizontal (topo/base)
                        const sign = dy_orig > 0 ? 1 : -1;
                        return {
                            x: center.x - sign * halfHeight * (dx_orig / dy_orig),
                            y: center.y - sign * halfHeight
                        };
                    }
                };
                
                // O ponto final está na borda do 'toNode', aproximando-se da direção (dx, dy)
                const endPoint = getIntersection(toCenter, toRect, dx, dy);
                // O ponto inicial está na borda do 'fromNode', aproximando-se da direção oposta (-dx, -dy)
                const startPoint = getIntersection(fromCenter, fromRect, -dx, -dy);
                
                return { startPoint, endPoint };
            }
            
            /**
             * Ativa o modo de conexão
             * @param {string} type - O tipo de relação
             */
            function setConnectionMode(type) {
                // Se o mesmo botão for clicado, desativa o modo
                if (connectionMode === type) {
                    resetConnectionMode();
                    return;
                }
                connectionMode = type;
                document.body.classList.add('connecting');
                relationshipBtns.forEach(btn => {
                    if (btn.dataset.type === type) {
                        btn.classList.add('bg-indigo-500', 'text-white');
                        btn.classList.remove('bg-gray-200', 'dark:bg-gray-700');
                    } else {
                        btn.classList.remove('bg-indigo-500', 'text-white');
                        btn.classList.add('bg-gray-200', 'dark:bg-gray-700');
                    }
                });
            }

            /**
             * Reseta/desativa o modo de conexão
             */
            function resetConnectionMode() {
                if (firstNode) {
                    firstNode.classList.remove('ring-4', 'ring-indigo-400');
                }
                connectionMode = null;
                firstNode = null;
                document.body.classList.remove('connecting');
                relationshipBtns.forEach(btn => {
                    btn.classList.remove('bg-indigo-500', 'text-white');
                    btn.classList.add('bg-gray-200', 'dark:bg-gray-700');
                });
            }
            
            /**
              * Lida com cliques nas caixas de classe quando em modo de conexão.
              * @param {MouseEvent} e - O evento de clique.
             */
            function handleConnectionClick(e) {
                if (!connectionMode) return;

                const clickedNode = e.currentTarget;

                if (!firstNode) {
                    firstNode = clickedNode;
                    firstNode.classList.add('ring-4', 'ring-indigo-400');
                } else if (firstNode !== clickedNode) {
                    drawConnection(firstNode, clickedNode, connectionMode);
                    resetConnectionMode();
                }
            }

            /**
             * Desenha uma linha de conexão SVG entre duas caixas de classe.
             * @param {HTMLElement} fromNode 
             * @param {HTMLElement} toNode 
             * @param {string} type 
             */
            function drawConnection(fromNode, toNode, type) {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.classList.add('connection-line');
                
                const { startPoint, endPoint } = calculateConnectionPoints(fromNode, toNode);

                line.setAttribute('x1', startPoint.x);
                line.setAttribute('y1', startPoint.y);
                line.setAttribute('x2', endPoint.x);
                line.setAttribute('y2', endPoint.y);

                // Define a seta apropriada
                if (type === 'inheritance' || type === 'composition' || type === 'aggregation') {
                    line.setAttribute('marker-end', `url(#arrow-${type})`);
                }

                svgCanvas.appendChild(line);

                connections.push({ from: fromNode.dataset.id, to: toNode.dataset.id, line, type });
            }

            /**
             * Atualiza as linhas conectadas a um elemento específico.
             * @param {HTMLElement} element 
             */
            function updateConnectionsForElement(element) {
                const elementId = element.dataset.id;

                connections.forEach(conn => {
                    if (conn.from === elementId || conn.to === elementId) {
                        const fromNode = document.querySelector(`[data-id="${conn.from}"]`);
                        const toNode = document.querySelector(`[data-id="${conn.to}"]`);

                        if (fromNode && toNode) {
                            const { startPoint, endPoint } = calculateConnectionPoints(fromNode, toNode);
                            conn.line.setAttribute('x1', startPoint.x);
                            conn.line.setAttribute('y1', startPoint.y);
                            conn.line.setAttribute('x2', endPoint.x);
                            conn.line.setAttribute('y2', endPoint.y);
                        }
                    }
                });
            }

            // --- Funções de arrastar ---
            
            /**
             * Chamada quando o mouse é pressionado em uma caixa de classe.
             * Inicia o processo de arrastar.
             * @param {MouseEvent} e - O evento do mouse.
             */
            function onMouseDown(e) {
                // Não arrastar se estivermos no modo de conexão
                if (connectionMode) return;

                // Previne o arrasto de texto ou outros elementos nativos
                e.preventDefault();
                
                activeElement = this;
                
                // Traz o elemento para a frente
                highestZIndex++;
                activeElement.style.zIndex = highestZIndex;

                const rect = activeElement.getBoundingClientRect();
                
                // Calcula o deslocamento do ponteiro do mouse em relação ao canto superior esquerdo do elemento
                offsetX = e.clientX - rect.left;
                offsetY = e.clientY - rect.top;
                
                document.body.classList.add('dragging');
                
                // Adiciona listeners globais para mover e soltar
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            }

            /**
             * Chamada quando o mouse se move pelo documento.
             * Move o elemento ativo se houver um.
             * @param {MouseEvent} e - O evento do mouse.
             */
            function onMouseMove(e) {
                if (!activeElement) return;
                
                const canvasRect = canvas.getBoundingClientRect();
                
                // Calcula a nova posição
                let newX = e.clientX - offsetX - canvasRect.left;
                let newY = e.clientY - offsetY - canvasRect.top;

                // Limita o movimento dentro do canvas
                newX = Math.max(0, Math.min(newX, canvasRect.width - activeElement.offsetWidth));
                newY = Math.max(0, Math.min(newY, canvasRect.height - activeElement.offsetHeight));

                // Aplica a nova posição
                activeElement.style.left = `${newX}px`;
                activeElement.style.top = `${newY}px`;
                
                // Atualiza as conexões
                updateConnectionsForElement(activeElement);
            }

            /**
             * Chamada quando o botão do mouse é solto.
             * Finaliza o processo de arrastar.
             */
            function onMouseUp() {
                activeElement = null;
                document.body.classList.remove('dragging');
                
                // Remove os listeners globais
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }

            // --- Event Listeners ---
            addClassBtn.addEventListener('click', createClass);
            clearBtn.addEventListener('click', clearCanvas);
            relationshipBtns.forEach(btn => {
                btn.addEventListener('click', () => setConnectionMode(btn.dataset.type));
            });
        });
    </script>
</body>
</html>

